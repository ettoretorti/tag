// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_COMMON_TAG_FLATBUF_H_
#define FLATBUFFERS_GENERATED_COMMON_TAG_FLATBUF_H_

#include "flatbuffers/flatbuffers.h"

namespace tag {
namespace flatbuf {

struct Vec2;

struct Color;

struct Circle;

struct Polygon;

/// Represents a 2 dimensional vector
MANUALLY_ALIGNED_STRUCT(4) Vec2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Vec2() { memset(this, 0, sizeof(Vec2)); }
  Vec2(const Vec2 &_o) { memcpy(this, &_o, sizeof(Vec2)); }
  Vec2(float _x, float _y)
    : x_(flatbuffers::EndianScalar(_x)), y_(flatbuffers::EndianScalar(_y)) { }

  /// First component
  float x() const { return flatbuffers::EndianScalar(x_); }
  void mutate_x(float _x) { flatbuffers::WriteScalar(&x_, _x); }
  /// Second component
  float y() const { return flatbuffers::EndianScalar(y_); }
  void mutate_y(float _y) { flatbuffers::WriteScalar(&y_, _y); }
};
STRUCT_END(Vec2, 8);

/// Represents a color in RGBA space
MANUALLY_ALIGNED_STRUCT(1) Color FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t r_;
  uint8_t g_;
  uint8_t b_;
  uint8_t a_;

 public:
  Color() { memset(this, 0, sizeof(Color)); }
  Color(const Color &_o) { memcpy(this, &_o, sizeof(Color)); }
  Color(uint8_t _r, uint8_t _g, uint8_t _b, uint8_t _a)
    : r_(flatbuffers::EndianScalar(_r)), g_(flatbuffers::EndianScalar(_g)), b_(flatbuffers::EndianScalar(_b)), a_(flatbuffers::EndianScalar(_a)) { }

  /// Red channel
  uint8_t r() const { return flatbuffers::EndianScalar(r_); }
  void mutate_r(uint8_t _r) { flatbuffers::WriteScalar(&r_, _r); }
  /// Green channel
  uint8_t g() const { return flatbuffers::EndianScalar(g_); }
  void mutate_g(uint8_t _g) { flatbuffers::WriteScalar(&g_, _g); }
  /// Blue channel
  uint8_t b() const { return flatbuffers::EndianScalar(b_); }
  void mutate_b(uint8_t _b) { flatbuffers::WriteScalar(&b_, _b); }
  /// Alpha channel
  uint8_t a() const { return flatbuffers::EndianScalar(a_); }
  void mutate_a(uint8_t _a) { flatbuffers::WriteScalar(&a_, _a); }
};
STRUCT_END(Color, 4);

/// Represents a circle
struct Circle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CENTER = 4,
    VT_RADIUS = 6
  };
  /// The circle's center point
  const Vec2 *center() const { return GetStruct<const Vec2 *>(VT_CENTER); }
  Vec2 *mutable_center() { return GetStruct<Vec2 *>(VT_CENTER); }
  /// The circle's radius, defaults to 1.0 because that's the default player radius
  float radius() const { return GetField<float>(VT_RADIUS, 1.0f); }
  bool mutate_radius(float _radius) { return SetField(VT_RADIUS, _radius); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Vec2>(verifier, VT_CENTER) &&
           VerifyField<float>(verifier, VT_RADIUS) &&
           verifier.EndTable();
  }
};

struct CircleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_center(const Vec2 *center) { fbb_.AddStruct(Circle::VT_CENTER, center); }
  void add_radius(float radius) { fbb_.AddElement<float>(Circle::VT_RADIUS, radius, 1.0f); }
  CircleBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  CircleBuilder &operator=(const CircleBuilder &);
  flatbuffers::Offset<Circle> Finish() {
    auto o = flatbuffers::Offset<Circle>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<Circle> CreateCircle(flatbuffers::FlatBufferBuilder &_fbb,
    const Vec2 *center = 0,
    float radius = 1.0f) {
  CircleBuilder builder_(_fbb);
  builder_.add_radius(radius);
  builder_.add_center(center);
  return builder_.Finish();
}

/// Represents a convex (!) polygon
struct Polygon FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VERTICES = 4
  };
  /// The polygon's vertices, in a counter-clockwise winding
  const flatbuffers::Vector<const Vec2 *> *vertices() const { return GetPointer<const flatbuffers::Vector<const Vec2 *> *>(VT_VERTICES); }
  flatbuffers::Vector<const Vec2 *> *mutable_vertices() { return GetPointer<flatbuffers::Vector<const Vec2 *> *>(VT_VERTICES); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_VERTICES) &&
           verifier.Verify(vertices()) &&
           verifier.EndTable();
  }
};

struct PolygonBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_vertices(flatbuffers::Offset<flatbuffers::Vector<const Vec2 *>> vertices) { fbb_.AddOffset(Polygon::VT_VERTICES, vertices); }
  PolygonBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  PolygonBuilder &operator=(const PolygonBuilder &);
  flatbuffers::Offset<Polygon> Finish() {
    auto o = flatbuffers::Offset<Polygon>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<Polygon> CreatePolygon(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const Vec2 *>> vertices = 0) {
  PolygonBuilder builder_(_fbb);
  builder_.add_vertices(vertices);
  return builder_.Finish();
}

inline flatbuffers::Offset<Polygon> CreatePolygonDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<const Vec2 *> *vertices = nullptr) {
  return CreatePolygon(_fbb, vertices ? _fbb.CreateVector<const Vec2 *>(*vertices) : 0);
}

}  // namespace flatbuf
}  // namespace tag

#endif  // FLATBUFFERS_GENERATED_COMMON_TAG_FLATBUF_H_
