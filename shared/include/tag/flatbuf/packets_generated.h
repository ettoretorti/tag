// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_PACKETS_TAG_FLATBUF_H_
#define FLATBUFFERS_GENERATED_PACKETS_TAG_FLATBUF_H_

#include "flatbuffers/flatbuffers.h"

#include "common_generated.h"
#include "gamestate_generated.h"
#include "inputs_generated.h"
#include "map_generated.h"

namespace tag {
namespace flatbuf {

struct ACK;

struct NAK;

/// A packet sent from a client realtime
enum ClientPacketRT {
  ClientPacketRT_NONE = 0,
  ClientPacketRT_PlayerInput = 1,
  ClientPacketRT_MIN = ClientPacketRT_NONE,
  ClientPacketRT_MAX = ClientPacketRT_PlayerInput
};

inline const char **EnumNamesClientPacketRT() {
  static const char *names[] = { "NONE", "PlayerInput", nullptr };
  return names;
}

inline const char *EnumNameClientPacketRT(ClientPacketRT e) { return EnumNamesClientPacketRT()[static_cast<int>(e)]; }

inline bool VerifyClientPacketRT(flatbuffers::Verifier &verifier, const void *union_obj, ClientPacketRT type);

/// A packet sent from the server realtime
enum ServerPacketRT {
  ServerPacketRT_NONE = 0,
  ServerPacketRT_Snapshot = 1,
  ServerPacketRT_MIN = ServerPacketRT_NONE,
  ServerPacketRT_MAX = ServerPacketRT_Snapshot
};

inline const char **EnumNamesServerPacketRT() {
  static const char *names[] = { "NONE", "Snapshot", nullptr };
  return names;
}

inline const char *EnumNameServerPacketRT(ServerPacketRT e) { return EnumNamesServerPacketRT()[static_cast<int>(e)]; }

inline bool VerifyServerPacketRT(flatbuffers::Verifier &verifier, const void *union_obj, ServerPacketRT type);

/// A reliable packet sent from a client
enum ClientPacket {
  ClientPacket_NONE = 0,
  ClientPacket_ACK = 1,
  ClientPacket_NAK = 2,
  ClientPacket_MIN = ClientPacket_NONE,
  ClientPacket_MAX = ClientPacket_NAK
};

inline const char **EnumNamesClientPacket() {
  static const char *names[] = { "NONE", "ACK", "NAK", nullptr };
  return names;
}

inline const char *EnumNameClientPacket(ClientPacket e) { return EnumNamesClientPacket()[static_cast<int>(e)]; }

inline bool VerifyClientPacket(flatbuffers::Verifier &verifier, const void *union_obj, ClientPacket type);

/// A reliable packet sent from the server
enum ServerPacket {
  ServerPacket_NONE = 0,
  ServerPacket_ACK = 1,
  ServerPacket_NAK = 2,
  ServerPacket_MIN = ServerPacket_NONE,
  ServerPacket_MAX = ServerPacket_NAK
};

inline const char **EnumNamesServerPacket() {
  static const char *names[] = { "NONE", "ACK", "NAK", nullptr };
  return names;
}

inline const char *EnumNameServerPacket(ServerPacket e) { return EnumNamesServerPacket()[static_cast<int>(e)]; }

inline bool VerifyServerPacket(flatbuffers::Verifier &verifier, const void *union_obj, ServerPacket type);

/// Acknowledgement of previous messages
struct ACK FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ACKBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  ACKBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ACKBuilder &operator=(const ACKBuilder &);
  flatbuffers::Offset<ACK> Finish() {
    auto o = flatbuffers::Offset<ACK>(fbb_.EndTable(start_, 0));
    return o;
  }
};

inline flatbuffers::Offset<ACK> CreateACK(flatbuffers::FlatBufferBuilder &_fbb) {
  ACKBuilder builder_(_fbb);
  return builder_.Finish();
}

struct NAK FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct NAKBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  NAKBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  NAKBuilder &operator=(const NAKBuilder &);
  flatbuffers::Offset<NAK> Finish() {
    auto o = flatbuffers::Offset<NAK>(fbb_.EndTable(start_, 0));
    return o;
  }
};

inline flatbuffers::Offset<NAK> CreateNAK(flatbuffers::FlatBufferBuilder &_fbb) {
  NAKBuilder builder_(_fbb);
  return builder_.Finish();
}

inline bool VerifyClientPacketRT(flatbuffers::Verifier &verifier, const void *union_obj, ClientPacketRT type) {
  switch (type) {
    case ClientPacketRT_NONE: return true;
    case ClientPacketRT_PlayerInput: return verifier.VerifyTable(reinterpret_cast<const tag::flatbuf::PlayerInput *>(union_obj));
    default: return false;
  }
}

inline bool VerifyServerPacketRT(flatbuffers::Verifier &verifier, const void *union_obj, ServerPacketRT type) {
  switch (type) {
    case ServerPacketRT_NONE: return true;
    case ServerPacketRT_Snapshot: return verifier.VerifyTable(reinterpret_cast<const tag::flatbuf::Snapshot *>(union_obj));
    default: return false;
  }
}

inline bool VerifyClientPacket(flatbuffers::Verifier &verifier, const void *union_obj, ClientPacket type) {
  switch (type) {
    case ClientPacket_NONE: return true;
    case ClientPacket_ACK: return verifier.VerifyTable(reinterpret_cast<const ACK *>(union_obj));
    case ClientPacket_NAK: return verifier.VerifyTable(reinterpret_cast<const NAK *>(union_obj));
    default: return false;
  }
}

inline bool VerifyServerPacket(flatbuffers::Verifier &verifier, const void *union_obj, ServerPacket type) {
  switch (type) {
    case ServerPacket_NONE: return true;
    case ServerPacket_ACK: return verifier.VerifyTable(reinterpret_cast<const ACK *>(union_obj));
    case ServerPacket_NAK: return verifier.VerifyTable(reinterpret_cast<const NAK *>(union_obj));
    default: return false;
  }
}

}  // namespace flatbuf
}  // namespace tag

#endif  // FLATBUFFERS_GENERATED_PACKETS_TAG_FLATBUF_H_
